#!/bin/bash
# Run Single-Point v 0.2

# environment variables
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:${HOME}/software/orca/openmpi-4.1.6/lib
export PATH=$PATH:${HOME}/software/orca/openmpi-4.1.6/bin
export ORCA_EXE=${HOME}/software/orca/orca_6_0_0_shared_openmpi416/orca

usage() {
    echo "Run Single-Point" >&2
    echo "Usage: $0 [option] <xyz file> [charge] [multiplicity]" >&2
    echo "Options:" >&2
    echo "         -h             help" >&2
    echo "         -f             force      Start fresh calculations, if previous calculations exist, move to backup." >&2
    echo "         -c             clean      Removes unfinished outputs, reports finished results. No calculation performed." >&2
    echo "         -s             sequential Calculate all structures in sequential order. Default is random order." >&2
    echo "                                   When huge number of folders are present, accessing in unsorted order is faster." >&2
    echo "                                   Furthermore, if multiple jobs run in parallel, random order reduces collision." >&2
    echo "         -t <hh:mm::ss> timer      After duration, stop calculation, report finished results." >&2
    echo "         -n             no_report  Skip final report of finished results." >&2
    exit 1
}

while getopts "hfcst:n" opt; do
    case $opt in
        h) usage;;
        f) flag_force="true" ;;
        c) flag_clean="true" ;;
        s) flag_seque="true" ;;
        t) timer_duration="$OPTARG"
            # Validate timer input format
            if [[ -n $timer_duration && ! $timer_duration =~ ^([0-9]{2}):([0-9]{2}):([0-9]{2})$ ]]; then
              echo "Error: Duration must be in hh:mm:ss format." >&2
              usage
            fi
            IFS=: read -r hours minutes seconds <<< "$timer_duration"
            timer_duration_seconds=$((10#$hours * 3600 + 10#$minutes * 60 + 10#$seconds))
            start_time=$(date +%s)
            ;;
        n) flag_norep="true" ;;
        *) echo "Invalid option: -${OPTARG}." >&2; usage;;
    esac
done

# Remaining arguments
shift $((OPTIND - 1))

# Check if at least one argument is provided
if [ "$#" -lt 1 ]; then
    usage
fi

# Optional second argument
if [ -n "$2" ]; then
    chg="$2"
else
    chg="0"
fi

# Optional third argument
if [ -n "$3" ]; then
    mult="$3"
else
    mult="1"
fi

fin=$1
fn=${fin%.xyz}
chgmult="${chg} ${mult}"

WD="${PWD}"
sdir="${fn}.DIR"

# prepare inputs
if [ "$flag_force" == "true" ] || [ ! -d "${sdir}" ]; then
  [ -d "${sdir}" ] && rm -rf "${sdir}.bk" && mv "${sdir}" "${sdir}.bk" && echo "${sdir} exists, renaming to backup" >> "${WD}/${sdir}.bk/pid$$.log"
  rm -rf "${sdir}"
  mkdir -p "${sdir}/calculations/"

  cd "${WD}/${sdir}/calculations"

  csplit -z <(echo '####CSPLIT####' && sed '/^[[:space:]]*[0-9]*[[:space:]]*$/{N;s/^.*\n/*\n####CSPLIT####\n%maxcore 6000\n%base "tmp"\n! DLPNO-CCSD(T) aug-cc-pVTZ aug-cc-pVTZ\/C TightSCF\n* xyz '"${chgmult}"'\n# COMMENT FROM XYZ FILE : /g}' ../../${fin} | tail -n +3 && echo '*') '/^####CSPLIT####$/' '{*}'

  [ "$flag_seque" == "true" ] && filelist=$(ls xx*) || filelist=$(ls -f -I . -I .. | grep '^xx')
  for file in ${filelist}; do
    folder=${file#xx}
    mkdir "c${folder}/"
    mv "${file}" "c${folder}/config.inp"
  done
fi

# run Orca
cd "${WD}/${sdir}/calculations"

[ "$flag_seque" == "true" ] && folderlist=$(ls c*/ -d) || folderlist=$(ls -f -I . -I .. | grep '^c' | shuf)
for folder in ${folderlist}; do

  cd "${WD}/${sdir}/calculations"
  cd "$folder"

  # if clean

  [ "$flag_clean" == "true" ] && [ "$(grep -s 'TOTAL RUN TIME:' config.out | wc -l)" -eq 0 ] && rm -f config.out tmp.* # only removes files potentially generated by this script, if other files are created, this will not remove, but this folder will also be skipped by below codes
  [ "$flag_clean" == "true" ] && continue

  # if run

  [ "$(ls | wc -l)" -ne 1 ] && echo "skips ${folder}" >> "${WD}/${sdir}/pid$$.log" && continue # skip folder: calculation running or finished

  flag_run="true" && echo -n "${folder} running.." >> "${WD}/${sdir}/pid$$.log"

  # run
  $ORCA_EXE config.inp > config.out && rm tmp.* && echo "next" >> "${WD}/${sdir}/pid$$.log"

  # collect result for this pid
  id=${folder#c} && id=${id%/}
  grep "E(CCSD(T))" config.out | sed 's/^.* //g' | awk '{printf("%s %.17f kcal/mol\n", $1, ($1)*627.5096)}' | paste -d' ' <(echo "$((10#${id}))") -

  # timer
  elapsed=$(( $(date +%s) - start_time ))
  [[ -n $timer_duration && elapsed -ge timer_duration_seconds ]] && echo "Timeout." | tee -a "${WD}/${sdir}/pid$$.log" >&2 && break;

done > "${WD}/${sdir}/pid$$.dat"

## uncomment if needed: if clean, no need to continue. (won't collect results)
#[ "$flag_clean" == "true" ] && exit

# if clean, no need to check "nothing to run". Continue to collect result.
[ "$flag_clean" == "true" ] && flag_run="true" && echo "Cleaning done. Now collecting result.." | tee -a "${WD}/${sdir}/pid$$.log" >&2

# check if nothing to run
[ "$flag_run" != "true" ] && echo "Nothing to run! All calculation folders are: 1. finished; or 2. being run by another process; or 3. failed. In case 3, make sure no other process is running, then try cleaning the calculation folder (use -c flag)." | tee -a "${WD}/${sdir}/pid$$.log" >&2

# check if skip report result
[ "$flag_norep" != "true" ] && echo "Now collecting result.." | tee -a "${WD}/${sdir}/pid$$.log" >&2 || exit

# collect result
cd "${WD}/${sdir}/calculations" || exit 1

[ "$flag_seque" == "true" ] && folderlist=$(ls c*/ -d) || folderlist=$(ls -f -I . -I .. | grep '^c' | sort)
for folder in ${folderlist}; do
  cd "${WD}/${sdir}/calculations"
  [ ! -d "$folder" ] && continue # check isfolder
  cd "$folder"
  id=${folder#c} && id=${id%/}
  grep "E(CCSD(T))" config.out | sed 's/^.* //g' | awk '{printf("%s %.17f kcal/mol\n", $1, ($1)*627.5096)}' | paste -d' ' <(echo "$((10#${id}))") -
done | tee "${WD}/${fn}.dat"
